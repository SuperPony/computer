# design-pattern

设计模式,目录代表实现语言。

# Index

- 创建型模式；
  - 单例模式
  - 简单工厂模式
  - 抽象工厂模式
  - 工厂方法模式
- 结构型模式
  - 代理模式
  - 装饰器模式
- 行为模式
  - 策略模式
  - 模版模式

# 创建型模式(Creational Patterns)

创建型模式提供了一种在创建对象时隐藏创建逻辑的能力，而不是直接实例化对象；

## 单例模式(Singleton Patterns)

单例模式指全局只能有一个实例，并且它负责创建自己的对象。单例模式的好处在于，减少内存、性能开销，同时防止多个实例产生冲突；也正因为单例模式保证了实例的全局唯一，而且之被初始化一次，所以比较适合用于创建全局共享，且只需初始化一次的场景，例如，数据库实例、全局配置等。

单例模式分为两种：

- 饿汉方式：指全局实例在包被加载时创建，该方式有种弊端，即如果初始化耗时，会导致程序加载时间变长；
- 懒汉方式：则指实例在第一次使用时被创建，该方式使用较多，但缺点在于非并发安全，故而在高并发的场景下，需要加锁。

## 工厂模式(Factory Patterns)

工厂模式是面向对象编程中最常用的模式之一，用于构造实例；

工厂模式分为三种：

- 简单工厂模式：接收一些参数，然后返回相应实例的函数；
- 抽象工厂模式：与简单工厂相似，其区别在于返回接口而不是实例，其好处在于，在不公开内部实现的情况下，让外部使用提供的各种功能；
- 工厂方法模式：通过工厂函数创建并返回多种”子工厂“，每种子工厂负责对应类的实例化，从而实现将创建对象的职责交由子类负责；

工厂方法模式的好处在于，简单模式下，如果创建的对象变动，就需要变动工厂函数，这导致对象与工厂函数耦合性过高；而工厂方法模式由子类负责创建对象，从而避免了对象与工厂函数之间的耦合。

# 结构型模式(Structural Pattern)

该类型模式特点在于关注类和对象的组合，通过继承来组合接口和定义组合对象获得新功能。

## 代理模式(Proxy Pattern)

代理模式可以为另一个对象提供一个占位符，以控制对这个对象的访问；主要用于对象不适合让外部直接访问的场景。

代理模式优点：

- 在客户端与目标对象之间起到一个中介和保护目标对象的作用；
- 代理对象可拓展目标对象的功能；
- 能将客户端与目标对象分离，从而达到一定的接耦合效果。

代理模式缺点：

- 增大了开发成本、系统复杂度；
- 添加了代理对象后，导致系统开销增加；

## 装饰器模式(Decorator Pattern)

装饰器模式用于动态的为对象进行功能的增强；
优点：

- 比继承更灵活，在不改变原对象的情况下，动态的为对象添加一些方法或增强；
- 通过使用不同的装饰器可以为对象增加不同的效果；
- 该模式完全遵守开闭原则。

缺点：

- 对导致增添许多子类（装饰器），过度使用导致程序复杂度攀升。

# 行为模式(Behavioral Pattern)

行为模式的特点在于关注对象之间的通信。

## 策略模式(Strategy Pattern)

策略模式定义了一组算法，并将每个算法封装起来，并使他们可以互相调换。在实际中，适用于需要根据不同的场景，采取不同策略的场景。

## 模版模式(Template Pattern)

模版模式定义了一个操作算法中的骨架，而将一些具体细节延迟到子类中；通过模版模式，可以在不改变算法结构的情况下，就能够重写算法中的某些特定步骤。
